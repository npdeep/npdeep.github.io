<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coins, Scales and Error Correcting Codes | Bits & Qubits</title><meta name=keywords content><meta name=description content="This post is inspired by Pradeep Mutalik&rsquo;s Quanta article on coin puzzles.
It is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?
Let&rsquo;s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices."><meta name=author content><link rel=canonical href=http://npdeep.github.io/expositions/coin-puzzles/><link crossorigin=anonymous href=/assets/css/stylesheet.min.8b2173082ac777566603fa3349c9e6fb3d9999ef4542c3c09caf828d9eb5a089.css integrity="sha256-iyFzCCrHd1ZmA/ozScnm+z2Zme9FQsPAnK+CjZ61oIk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://npdeep.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://npdeep.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://npdeep.github.io/favicon-32x32.png><link rel=apple-touch-icon href=http://npdeep.github.io/apple-touch-icon.png><link rel=mask-icon href=http://npdeep.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Coins, Scales and Error Correcting Codes"><meta property="og:description" content="This post is inspired by Pradeep Mutalik&rsquo;s Quanta article on coin puzzles.
It is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?
Let&rsquo;s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices."><meta property="og:type" content="article"><meta property="og:url" content="http://npdeep.github.io/expositions/coin-puzzles/"><meta property="article:section" content="expositions"><meta property="article:published_time" content="2022-07-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-07-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Coins, Scales and Error Correcting Codes"><meta name=twitter:description content="This post is inspired by Pradeep Mutalik&rsquo;s Quanta article on coin puzzles.
It is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?
Let&rsquo;s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Technical Notes","item":"http://npdeep.github.io/expositions/"},{"@type":"ListItem","position":3,"name":"Coins, Scales and Error Correcting Codes","item":"http://npdeep.github.io/expositions/coin-puzzles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coins, Scales and Error Correcting Codes","name":"Coins, Scales and Error Correcting Codes","description":"This post is inspired by Pradeep Mutalik\u0026rsquo;s Quanta article on coin puzzles.\nIt is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?\nLet\u0026rsquo;s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices.","keywords":[],"articleBody":"This post is inspired by Pradeep Mutalik’s Quanta article on coin puzzles.\nIt is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?\nLet’s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices. Your prior probability distribution of a coin being faulty is a uniform one. $$\\text{Prob}(\\text{coin $i$ is heavier}) = \\frac{1}{8}$$ That is three bits of uncertainty $2^3 = 8$.\nA measurement on a scale gives you three possible outcomes: left heavy, balanced, right heavy. Each measurement, thus, gives you $\\log(3)/\\log(2) = 1.58$ bits of information.\nYou should be able to detect the faulty coin in $3/1.58 \\approx 2$ separate weighings.\nThe way to actually do it is as follows:\nMeasure coin {1, 2, 3} and {4, 5, 6} If they are balanced, the heavy coin is in {7, 8}. Put them on a scale to identify the heavy one. If they are unbalanced, you know which side has the heavier coin. Say it is {1, 2, 3}, weigh 1 and 2. If they balance, 3 is heavier. If they don’t balance, we have our answer. Non-adaptive protocol? The protocol I have described above is adaptive, meaning that the one weighing (or a measurement) informs what to weigh next.\nOne thing I have wondered is whether there is a non-adaptive way of identifying the heavier coin. That is, fix the set of coins you are going to measure and measure them without a complicated decision tree. Then use the measurement data to identify the bad coin.\nError Correction The error correction view on this problem goes like the following.\nYou are given 8 bits of data. One of the bit is corrupted. Identify which one. In error-correction theory, this is done using parity check operations.\nIn our case, the difference is that, while parity check gives you a binary syndrome, the scale we are using gives us a ternary syndrome. How do you reconcile the two bases? One way of doing this is by creating a new family of ternary syndromes. A parity check only gives you a boolean output. Maybe we can do better.\nHere is a suggestion. Give $N$ bits of data, representing $N$ coins, construct a set of new syndrome vectors $M^{(i)} \\in {0, 1, -1}^N $ that gives the following ternary syndrome. $$S_i(\\mathbf{x}) = \\sum_{k=1}^N M^{(i)}_k \\cdot x_k \\mod 2$$\nThe 1’s in the syndrome string $M$ corresponds to the coins on the left pan of the scale, the -1’s correspond do the coins that go on the right pan and the zeros correspond to coins that we don’t use.\nTo make it consistent with a sensible weighing operation, we also demand that the number of $1$ equals the number of $-1$. That is, it only makes sense to weigh equal number of coins on both pans. Otherwise, the measurement is silly.\n$$\\sum_{k} M^{(i)}_k = 0$$\nWe now need to find a set of vectors $M^{(i)}$ such that two syndrome measurements can uniquely identify the location of the error (or the heavy coin).\nThe two vectors (among many others) that work are $$ M^{(1)} = (0, 0, 1, 1, 1, -1, -1, -1) \\quad M^{(2)} = (1, -1, 0, 1, -1, 0, 1, -1) $$\nBoth of these correspond to weighing two set of three coins at a time.\nWe can check how the syndromes we get correspond to the position of the faulty bit (or the heavier coin).\nError Position $\\to$ 0 1 2 3 4 5 6 7 Syndrome 1 0 0 1 1 1 2 2 2 Syndrome 2 1 2 0 1 2 0 1 2 Each pair of syndrome uniquely identifies the faulty bit.\nSo, there you go, you have a way to find the heavier coin using non-adaptive measurements.\n","wordCount":"658","inLanguage":"en","datePublished":"2022-07-30T00:00:00Z","dateModified":"2022-07-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://npdeep.github.io/expositions/coin-puzzles/"},"publisher":{"@type":"Organization","name":"Bits \u0026 Qubits","logo":{"@type":"ImageObject","url":"http://npdeep.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://npdeep.github.io accesskey=h title="Bits & Qubits (Alt + H)">Bits & Qubits</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://npdeep.github.io/dear-julia/ title="Dear Julia"><span>Dear Julia</span></a></li><li><a href=http://npdeep.github.io/expositions/ title=Expositions><span>Expositions</span></a></li></ul></nav><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Coins, Scales and Error Correcting Codes</h1><div class=post-meta><span title='2022-07-30 00:00:00 +0000 UTC'>July 30, 2022</span></div></header><div class=post-content><p>This post is inspired by <a href=https://www.quantamagazine.org/puzzles-on-weighing-truth-with-a-balance-scale-20220627/>Pradeep Mutalik&rsquo;s Quanta article</a> on coin puzzles.</p><p>It is the usual setup. You have eight coins. One of them is heavier than the other. You are also given a scale. How many weighings do you need to identify the bad coin?</p><p>Let&rsquo;s start with the information theoretic perspective on this. The uncertainty here is the position/label of the coin that is wrong. There are eight choices. Your prior probability distribution of a coin being faulty is a uniform one.
$$\text{Prob}(\text{coin $i$ is heavier}) = \frac{1}{8}$$
That is three bits of uncertainty $2^3 = 8$.</p><p>A measurement on a scale gives you three possible outcomes: left heavy, balanced, right heavy. Each measurement, thus, gives you $\log(3)/\log(2) = 1.58$ bits of information.</p><p>You should be able to detect the faulty coin in $3/1.58 \approx 2$ separate weighings.</p><p>The way to actually do it is as follows:</p><ul><li>Measure coin {1, 2, 3} and {4, 5, 6}<ul><li>If they are balanced, the heavy coin is in {7, 8}. Put them on a scale to identify the heavy one.</li><li>If they are unbalanced, you know which side has the heavier coin. Say it is {1, 2, 3}, weigh 1 and 2.<ul><li>If they balance, 3 is heavier.</li><li>If they don&rsquo;t balance, we have our answer.</li></ul></li></ul></li></ul><h3 id=non-adaptive-protocol>Non-adaptive protocol?<a hidden class=anchor aria-hidden=true href=#non-adaptive-protocol>#</a></h3><p>The protocol I have described above is <strong>adaptive</strong>, meaning that the one weighing (or a measurement) informs what to weigh next.</p><p>One thing I have wondered is whether there is a non-adaptive way of identifying the heavier coin. That is, fix the set of coins you are going to measure and measure them without a complicated decision tree. Then use the measurement data to identify the bad coin.</p><hr><h2 id=error-correction>Error Correction<a hidden class=anchor aria-hidden=true href=#error-correction>#</a></h2><p>The error correction view on this problem goes like the following.</p><p>You are given 8 bits of data. One of the bit is corrupted. Identify which one. In error-correction theory, this is done using parity check operations.</p><p>In our case, the difference is that, while parity check gives you a binary syndrome, the scale we are using gives us a ternary syndrome. How do you reconcile the two bases? One way of doing this is by creating a new family of ternary syndromes. A parity check only gives you a boolean output. Maybe we can do better.</p><p>Here is a suggestion. Give $N$ bits of data, representing $N$ coins, construct a set of new syndrome vectors $M^{(i)} \in {0, 1, -1}^N $ that gives the following ternary syndrome.
$$S_i(\mathbf{x}) = \sum_{k=1}^N M^{(i)}_k \cdot x_k \mod 2$$</p><p>The 1&rsquo;s in the syndrome string $M$ corresponds to the coins on the left pan of the scale, the -1&rsquo;s correspond do the coins that go on the right pan and the zeros correspond to coins that we don&rsquo;t use.</p><p>To make it consistent with a sensible weighing operation, we also demand that the number of $1$ equals the number of $-1$. That is, it only makes sense to weigh equal number of coins on both pans. Otherwise, the measurement is silly.</p><p>$$\sum_{k} M^{(i)}_k = 0$$</p><p>We now need to find a set of vectors $M^{(i)}$ such that two syndrome measurements can uniquely identify the location of the error (or the heavy coin).</p><p>The two vectors (among many others) that work are
$$
M^{(1)} = (0, 0, 1, 1, 1, -1, -1, -1) \quad M^{(2)} = (1, -1, 0, 1, -1, 0, 1, -1)
$$</p><p>Both of these correspond to weighing two set of three coins at a time.</p><p>We can check how the syndromes we get correspond to the position of the faulty bit (or the heavier coin).</p><table><thead><tr><th>Error Position $\to$</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>Syndrome 1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Syndrome 2</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>Each pair of syndrome uniquely identifies the faulty bit.</p><p>So, there you go, you have a way to find the heavier coin using non-adaptive measurements.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://npdeep.github.io>Bits & Qubits</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>